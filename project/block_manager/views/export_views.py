from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.http import HttpResponse

from block_manager.serializers import ExportRequestSerializer
from block_manager.services.tensorflow_codegen import generate_tensorflow_code
from block_manager.services.pytorch_codegen import generate_pytorch_code

import zipfile
import io


@api_view(['POST'])
def export_model(request):
    """
    Export model code with professional class-based structure.

    Generates multiple files (model, train, dataset, config) for both frameworks.
    Returns a zip file containing all generated files.

    This endpoint matches the frontend API contract: /api/export
    """
    # Validate incoming data
    nodes = request.data.get('nodes', [])
    edges = request.data.get('edges', [])
    export_format = request.data.get('format', 'pytorch')
    project_name = request.data.get('projectName', 'GeneratedModel')

    if not nodes:
        return Response(
            {'error': 'No nodes provided'},
            status=status.HTTP_400_BAD_REQUEST
        )

    try:
        # Generate code based on framework
        if export_format == 'pytorch':
            generated = generate_pytorch_code(nodes, edges, project_name)
        elif export_format == 'tensorflow':
            generated = generate_tensorflow_code(nodes, edges, project_name)
        else:
            return Response(
                {'error': f'Unsupported export format: {export_format}'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Create a zip file with all generated files
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # Add model file
            zip_file.writestr('model.py', generated.get('model', ''))
            # Add training script
            zip_file.writestr('train.py', generated.get('train', ''))
            # Add dataset file
            zip_file.writestr('dataset.py', generated.get('dataset', ''))
            # Add config file
            zip_file.writestr('config.py', generated.get('config', ''))

            # Add README
            readme_content = f"""# {project_name} - Generated by VisionForge

## Framework: {export_format.upper()}

This project was automatically generated from your visual architecture.

## Files:
- `model.py`: Contains the model architecture with separate layer classes
- `train.py`: Training script with best practices
- `dataset.py`: Dataset class template for loading your data
- `config.py`: Configuration file with all hyperparameters

## Usage:

1. Install dependencies:
   ```bash
   {"pip install torch torchvision" if export_format == 'pytorch' else "pip install tensorflow"}
   ```

2. Replace the dataset loading logic in `dataset.py` with your actual data.

3. Train the model:
   ```bash
   python train.py
   ```

## Model Architecture:
Each layer is implemented as a separate class for clarity and reusability.
The main model class combines all layers with proper type hints and documentation.

Generated with VisionForge
"""
            zip_file.writestr('README.md', readme_content)

        # Prepare response with zip file
        zip_buffer.seek(0)

        # Return as JSON response with base64 encoded zip for frontend compatibility
        import base64
        zip_base64 = base64.b64encode(zip_buffer.getvalue()).decode('utf-8')

        return Response({
            'success': True,
            'framework': export_format,
            'projectName': project_name,
            'files': {
                'model.py': generated.get('model', ''),
                'train.py': generated.get('train', ''),
                'dataset.py': generated.get('dataset', ''),
                'config.py': generated.get('config', '')
            },
            'zip': zip_base64,  # Base64 encoded zip file
            'filename': f'{project_name}_{export_format}.zip'
        })

    except Exception as e:
        # Pass detailed error messages to frontend
        import traceback
        traceback.print_exc()  # Log to console for debugging
        return Response(
            {
                'error': f'Code generation failed: {str(e)}',
                'details': str(e),
                'traceback': traceback.format_exc()
            },
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

